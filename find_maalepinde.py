#!env/bin/python3
"""
Find maalepinde in .xlsx document
"""
from __future__ import annotations

import re
import pandas as pd
from enum import Enum
from typing import Hashable, Sequence
from pandas import DataFrame, Series

EXCEL_FILE: str = 'Fagtabel_Excel_2023_all.xlsx'

# Match the text in the "MÅLEPINDE" field.
# Generated by our one-and-only ChatGPT.
MAALEPIND_PATTERN = re.compile(r'\d+\.\s(.+?)\r\n\n')


class ColumnNames(Enum):
    FAGNUMMER_COLUMN_NAME: str = 'NUMMER'
    MAALEPINDE_COLUMN_NAME: str = 'MÅLPINDE'
    SCORE_COLUMN_NAME: str = 'NIVEAU'


# We use a tuple, instead of a dict,
# so the order of the subject level becomes directly tied to its location in the tuple.
# We accept the fact that lookups are likely slightly slower than they would've been in a dict.
# Order is the lowest first.
LEVEL_ORDER: tuple[str, ...] = (
    '-',
    '2',
    '3',
    '4',
    'C',
    'B',
    'A',
)


def hent_maalepinde(excel_file: str, fagnr: int | Sequence[int] = None, sheet: str | int = None, only_best: bool = False) -> dict[int, set[tuple[int, tuple[str]]]]:
    """
    Find maalepinde for the provided fagnr in an .xlsx file.

    Currently, maalepinde for the provided fagnr across all sheets in the document,

    :param fagnr: fagnr of which the maalepinde should be found.
    :return: List of string maalepinde, stripped of \r\n\n and numberings
    """

    df: dict[str, DataFrame] = pd.read_excel(excel_file, sheet_name=sheet)

    # Stores all maalepinde for the provided fagnr,
    # of which we will find the ones with the higest score.
    tmp_maalepinde: dict[int, set[tuple[int, str]]] = {}

    if isinstance(fagnr, (int, str)):
        fagnr = {str(fagnr), }
    else:
        assert isinstance(fagnr, Sequence)
        fagnr = {str(fagnr) for fagnr in fagnr}

    for sheet in df.values():

        # Find the index of our desired columns once per sheet,
        # in case sheets are formatted differently.
        # This approach should support an arbritrary number of lines above the headers.
        # But it does assert the column names in the header, and that the values come below the headers.
        fagnummer_column_idx: int = None
        maalpinde_column_idx: int = None
        score_column_idx: int = None

        row: tuple[Hashable, Series]
        for row in sheet.iterrows():

            for index, column in enumerate(row[1]):

                match column:
                    case ColumnNames.FAGNUMMER_COLUMN_NAME.value:
                        assert fagnummer_column_idx is None, \
                            'There is probably something wrong if we find our header multiple times'
                        fagnummer_column_idx = index
                    case ColumnNames.MAALEPINDE_COLUMN_NAME.value:
                        assert maalpinde_column_idx is None, \
                            'There is probably something wrong if we find our header multiple times'
                        maalpinde_column_idx = index
                    case ColumnNames.SCORE_COLUMN_NAME.value:
                        assert score_column_idx is None, \
                            'There is probably something wrong if we find our header multiple times'
                        score_column_idx = index

                if fagnr is None or column in fagnr:

                    # We will match every row, when no fagnr is specified. But we still need to find the headers first.
                    if fagnr is None and None not in {fagnummer_column_idx, maalpinde_column_idx, score_column_idx}:
                        continue

                    # By now, we should've found all the headers, and know the location of our columns-of-interest.
                    assert None not in {fagnummer_column_idx, maalpinde_column_idx, score_column_idx}

                    assert column.isnumeric()  # .isnumeric() probably also includes floats
                    key = int(column)
                    if key not in tmp_maalepinde:
                        tmp_maalepinde[key] = set()
                    tmp_maalepinde[key].add((LEVEL_ORDER.index(row[1][score_column_idx]), row[1][maalpinde_column_idx]))

    # Now we want to find the 'set' of maalepinde with the highest scoring.
    if only_best:
        tmp_maalepinde: dict[int, set[tuple[int, tuple[str]]]] = {fagnr: {
            max(matches, key=(lambda maalepind_tpl: maalepind_tpl[0]))} for fagnr, matches in tmp_maalepinde.items()}

    # Use findall to extract matches
    # matches = MAALEPIND_PATTERN.findall(best_maalepinde)

    tmp_maalepinde: dict[int, set[tuple[int, tuple[str]]]] = {fagnr: {(maalepinde_tpl[0], tuple(match.strip() for match in MAALEPIND_PATTERN.findall(maalepinde_tpl[1]))) for maalepinde_tpl in maalepinde_set} for fagnr, maalepinde_set in tmp_maalepinde.items()}

    # Remove leading and trailing whitespaces from each match
    # result_list = [ in matches]

    return tmp_maalepinde


if __name__ == '__main__':

    # ml = hent_maalepinde(EXCEL_FILE, 17348)
    # for m in ml.values():
    #     for n in m:
    #         for i in n[1]:
    #             print(i)

    sw_test = hent_maalepinde(EXCEL_FILE, 16484, only_best=True)
    for m in sw_test.values():
        for n in m:
            for i in n[1]:
                print(i)
